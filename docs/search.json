[
  {
    "objectID": "intro.html#why-use-r",
    "href": "intro.html#why-use-r",
    "title": "1  Introduction to R Programming",
    "section": "",
    "text": "It’s free!\nBecause it’s open source, thousands of people have contributed packages and functions at a pace that proprietary softwares can’t compete with\nIt is very flexible and robust meaning there’s a lot you can do with it (including creating this very website!)\nIt is becoming widely used across many industries\nWe can create visualizations and perform quantitative analyses in the same system.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "intro.html#so-what-is-r",
    "href": "intro.html#so-what-is-r",
    "title": "1  Introduction to R Programming",
    "section": "1.2 So What is R?",
    "text": "1.2 So What is R?\nR is a command-line, object-oriented programming language commonly used for data analysis and statistics.\nCommand-line means that we have to give R commands in order for us to get it to do something. So for instance, if we wanted to know what the sum of 3 and 5 were, we can use R to solve this problem for us:\n\n## Adding 3 & 5 Together: ##\n3 + 5\n\n[1] 8\n\n\nObject-oriented means that we can save individual pieces of output as some name that we can use later. This is a super handy feature, especially when you have complicated scripts!\n\n## Saving the result of 3 + 5 as a ##\na &lt;- 3 + 5\na\n\n[1] 8",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "intro.html#what-can-r-do",
    "href": "intro.html#what-can-r-do",
    "title": "1  Introduction to R Programming",
    "section": "1.3 What Can R Do?",
    "text": "1.3 What Can R Do?\nWhat can R do? Well, for the purpose of data analytics, I am yet to find a limit of what it can do!\nIn this class, we will be using R as a tool for visualizing categorical and quantitative data through various means.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "intro.html#functions-in-r",
    "href": "intro.html#functions-in-r",
    "title": "1  Introduction to R Programming",
    "section": "1.4 Functions in R",
    "text": "1.4 Functions in R\nIn order to visualize data in R, we need to be able to import data into R. There are a variety of ways of importing data into R, but they largely depend on the type of datafile that you are importing (e.g., Excel file, CSV file, text file, etc.). While there are lots of different files which can be imported into R (Google and ChatGPT are excellent resources for searching for code for how to do something), we’ll mostly use two types in this class: Excel and CSV\nLet’s try importing the HEART.csv file into R. This file is part of the famous Framingham Heart Study.\nSince we set up our first class session by connecting to GitHub, we should have this file in our project folder already.\nTo read in this CSV file, we will use the read_csv function which is part of the readr package. Every function in R requires arguments specified inside of parentheses. We can think of packages like toolboxes within a mechanic’s workshop. Each toolbox contains different tools. A tool is like a function; we use specific tools (functions) to solve specific problems!\n\nread_csv is a tool we use to solve the problem of reading CSV files into R.\nThe read_csv tools is stored within the readr toolbox (package).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "intro.html#importing-data-into-r",
    "href": "intro.html#importing-data-into-r",
    "title": "1  Introduction to R Programming",
    "section": "1.5 Importing Data into R",
    "text": "1.5 Importing Data into R\nWhile many packages come installed in RStudio automatically, there are far, far more which we have to install from the web, including readr.\nTo install a package, we use the install.packages function:\n\n## Installing the readr package ##\ninstall.packages('readr')\n\nWe can also think of functions like mathematical functions; we have to supply the function with special inputs called arguments in order to get the desired output. For instance, in the install.packages function, we had to specify to the function which package we wanted to install.\nHow do we know what arguments to specify for a given function? There are lots of different ways, but one way we can do so is by using the ? operator.\n\n## What are the arguments of read_csv? ##\n?readr::read_csv\n\nAs we can see, there are a lot of arguments we can specify. However, we don’t need to specify most of them in this case. All of the arguments which have an = after them, like “col_names = TRUE”, will retain that specific argument unless you explicitly change it. I refer to these as optional arguments, those arguments whose value doesn’t necessarily need to be changed in order to get the function to execute.\nTo note, col_names = TRUE means that the columns of the CSV file have names. If they don’t, then we would change it to, col_names = FALSE and the column names will have generic names, (V1, V2, ... , VN).\nConversely, any argument which does not have an already specified value is a required argument, or one the user (that’s you!) must fill in for the function to execute. In the case of read_csv, that required argument is the file path!\n\nlibrary(readr)\nheart &lt;- read_csv(\"Introduction to R and RStudio/HEART.csv\")\n\nWhat about an Excel file? How do we import those? What if we want to read in the esoph.xlsx file? In this case, we can use a function called read_xlsx which is part of the package readxl. So just as before, we can run:\n\ninstall.packages('readxl')\nlibrary(readxl)\nesoph &lt;- read_xlsx(\"Introduction to R and RStudio/esoph.xlsx\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DATA 3230 - Data Visualization",
    "section": "",
    "text": "Preface\nWelcome to DATA 3230 - Data Visualization! My name is Dr Austin Brown and I am a faculty member in the School of Data Science and Analytics at Kennesaw State University.\nThe syllabus for the Fall 2024 term can be found here.\nThis course is designed to teach students not only how to create data visualizations, but how to create them in an appropriate and aesthetically pleasing manner.\n\n\nCoding Requirements\nIn this course, I use R programming and specifically elements of the tidyverse to teach students how to generate beautiful visualizations using the popular visualization package, ggplot2. Now, you may be asking yourself: “what if I don’t have experience with R programming? Can I still be successful?”\nThe answer is unequivocally, yes! We start from the basics and work our way up to more complex examples, making sure that you have all the relevant code and explanations you need to be successful in this class and beyond.\nAll I ask is that along the way, if you run into issues, be sure to ask for help! That’s what I’m here for!\nSo if you’re ready to learn how to tell stories with data through a visual medium, come along with me!\n\n\nReferences\nSome of the content I use to teach this course comes from:\n\nCommunicating Data with Tableau by Ben Jones\nR for Data Science 2nd Edition by Hadley Wickham, Mine Cetinkaya-Rundel, and Garrett Grolemund\nR Graphics Cookbook 2nd Edition by Winston Chang\n\n\n\nAccessing Content\nAll of the content for the course, including code and datasets, can be found at my GitHub repo for this course.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html#exploring-dataframes-using-r",
    "href": "intro.html#exploring-dataframes-using-r",
    "title": "1  Introduction to R Programming",
    "section": "1.6 Exploring Dataframes using R",
    "text": "1.6 Exploring Dataframes using R\nSo far we have imported some datasets into the RStudio environment…how do we know they imported correctly? The best way that I have found which uses a combination of some traditional functions is a function called glimpse which is part of an incredibly useful data wrangling package called dplyr:\n\ninstall.packages('dplyr')\nlibrary(dplyr)\nheart |&gt;\n  glimpse()\n\n\n\nRows: 5,209\nColumns: 17\n$ Status         &lt;chr&gt; \"Dead\", \"Dead\", \"Alive\", \"Alive\", \"Alive\", \"Alive\", \"Al…\n$ DeathCause     &lt;chr&gt; \"Other\", \"Cancer\", NA, NA, NA, NA, NA, \"Other\", NA, \"Ce…\n$ AgeCHDdiag     &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 57, 55, 79,…\n$ Sex            &lt;chr&gt; \"Female\", \"Female\", \"Female\", \"Female\", \"Male\", \"Female…\n$ AgeAtStart     &lt;dbl&gt; 29, 41, 57, 39, 42, 58, 36, 53, 35, 52, 39, 33, 33, 57,…\n$ Height         &lt;dbl&gt; 62.50, 59.75, 62.25, 65.75, 66.00, 61.75, 64.75, 65.50,…\n$ Weight         &lt;dbl&gt; 140, 194, 132, 158, 156, 131, 136, 130, 194, 129, 179, …\n$ Diastolic      &lt;dbl&gt; 78, 92, 90, 80, 76, 92, 80, 80, 68, 78, 76, 68, 90, 76,…\n$ Systolic       &lt;dbl&gt; 124, 144, 170, 128, 110, 176, 112, 114, 132, 124, 128, …\n$ MRW            &lt;dbl&gt; 121, 183, 114, 123, 116, 117, 110, 99, 124, 106, 133, 1…\n$ Smoking        &lt;dbl&gt; 0, 0, 10, 0, 20, 0, 15, 0, 0, 5, 30, 0, 0, 15, 30, 10, …\n$ AgeAtDeath     &lt;dbl&gt; 55, 57, NA, NA, NA, NA, NA, 77, NA, 82, NA, NA, NA, NA,…\n$ Cholesterol    &lt;dbl&gt; NA, 181, 250, 242, 281, 196, 196, 276, 211, 284, 225, 2…\n$ Chol_Status    &lt;chr&gt; NA, \"Desirable\", \"High\", \"High\", \"High\", \"Desirable\", \"…\n$ BP_Status      &lt;chr&gt; \"Normal\", \"High\", \"High\", \"Normal\", \"Optimal\", \"High\", …\n$ Weight_Status  &lt;chr&gt; \"Overweight\", \"Overweight\", \"Overweight\", \"Overweight\",…\n$ Smoking_Status &lt;chr&gt; \"Non-smoker\", \"Non-smoker\", \"Moderate (6-15)\", \"Non-smo…\n\n\nAs we visually inspect the first few rows of the HEART dataframe, we can see that the “Sex” variable appears to be categorical whereas the “Weight” variable appears to be quantitative.\n\nA quantitative variable is something which can be measured with a number, like dollars, time, height, weight, blood pressure, etc. R refers to these as “numeric” variables.\nA categorical variable is just the opposite. It is something which cannot be quantified and is more of a quality. These are things like sex, country of origin, hair color, cause of death etc. R refers to these as “character” variables.\n\nYou may be asking yourself, “why does this matter?” It’s important for two primary reasons:\n\nThe type of variable we are working with dictates to us which visualization methods would be most appropriate.\nIn terms of R programming, we can look at the variable “Sex” and “Height” in the heart dataframe and conclude that these are categorical and quantitative variables, respectively. But when we read the heart dataframe into R using readr::read_csv, we didn’t have to tell R what types of variables each column was; it by default scans each column and makes a best guess as to what type of variable the column contains.\n\nSo how can we know that R properly recognized the variables in the heart dataframe?\nLet’s take a second glimpse!\n\n\n\nheart |&gt;\n  glimpse()\n\nRows: 5,209\nColumns: 17\n$ Status         &lt;chr&gt; \"Dead\", \"Dead\", \"Alive\", \"Alive\", \"Alive\", \"Alive\", \"Al…\n$ DeathCause     &lt;chr&gt; \"Other\", \"Cancer\", NA, NA, NA, NA, NA, \"Other\", NA, \"Ce…\n$ AgeCHDdiag     &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 57, 55, 79,…\n$ Sex            &lt;chr&gt; \"Female\", \"Female\", \"Female\", \"Female\", \"Male\", \"Female…\n$ AgeAtStart     &lt;dbl&gt; 29, 41, 57, 39, 42, 58, 36, 53, 35, 52, 39, 33, 33, 57,…\n$ Height         &lt;dbl&gt; 62.50, 59.75, 62.25, 65.75, 66.00, 61.75, 64.75, 65.50,…\n$ Weight         &lt;dbl&gt; 140, 194, 132, 158, 156, 131, 136, 130, 194, 129, 179, …\n$ Diastolic      &lt;dbl&gt; 78, 92, 90, 80, 76, 92, 80, 80, 68, 78, 76, 68, 90, 76,…\n$ Systolic       &lt;dbl&gt; 124, 144, 170, 128, 110, 176, 112, 114, 132, 124, 128, …\n$ MRW            &lt;dbl&gt; 121, 183, 114, 123, 116, 117, 110, 99, 124, 106, 133, 1…\n$ Smoking        &lt;dbl&gt; 0, 0, 10, 0, 20, 0, 15, 0, 0, 5, 30, 0, 0, 15, 30, 10, …\n$ AgeAtDeath     &lt;dbl&gt; 55, 57, NA, NA, NA, NA, NA, 77, NA, 82, NA, NA, NA, NA,…\n$ Cholesterol    &lt;dbl&gt; NA, 181, 250, 242, 281, 196, 196, 276, 211, 284, 225, 2…\n$ Chol_Status    &lt;chr&gt; NA, \"Desirable\", \"High\", \"High\", \"High\", \"Desirable\", \"…\n$ BP_Status      &lt;chr&gt; \"Normal\", \"High\", \"High\", \"Normal\", \"Optimal\", \"High\", …\n$ Weight_Status  &lt;chr&gt; \"Overweight\", \"Overweight\", \"Overweight\", \"Overweight\",…\n$ Smoking_Status &lt;chr&gt; \"Non-smoker\", \"Non-smoker\", \"Moderate (6-15)\", \"Non-smo…\n\n\nSex, for example, we can imagine is a categorical variable as its values, male and female, are characteristics and not numbers.\n\nWe can tell R read it in as a categorical variable because it is coded as character (notice the &lt;chr&gt; to the right of the Sex variable name).\nHeight, on the other hand, we can imagine is a quantitative variable as its values are numbers!\n\nWe can tell R read it in as a quantitative variable because it is coded as double (notice the &lt;dbl&gt; to the right of the Height variable name).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "intro.html#examining-subsets-of-dataframes",
    "href": "intro.html#examining-subsets-of-dataframes",
    "title": "1  Introduction to R Programming",
    "section": "1.7 Examining Subsets of Dataframes",
    "text": "1.7 Examining Subsets of Dataframes\n\n1.7.1 Single Variable Analysis\nLet’s say I wanted to find the average or mean Age at Death from the heart dataframe. How would I go about doing that?\nFirst, I need to know how to isolate that single variable by itself. To do this, we make use of the dollar-sign operator after the name of our dataframe.\nYou can think of the dollar-sign operator like a door to your home. The name of the dataframe is the house itself, the dollar-sign is the door, and the variable name is the person we want to talk to inside of the house.\nSo the structure is: House$Person\nIf we enter the following command into our console, we can see that we have returned to us the observations contained withing the Age at Death column:\n\nheart$AgeAtDeath\n\n\n\n [1] 55 57 NA NA NA NA NA 77 NA 82\n\n\nSo now that we know how to isolate a single variable within a dataframe, let’s try finding the mean of this quantitative variable using the below code:\n\nmean(heart$AgeAtDeath)\n\n[1] NA\n\n\nWhat is returned to us in NA meaning “Not-Applicable.” How does this make any sense? Sometimes, when I get output that is different than what I’m expecting, I check the documentation to see if there are any arguments within the given function that might need changed to have the function return output I expect. Remember, we can do that with the ? operator:\n\n?mean\n\nWhat we find in the documentation is the structure of the function, just like we saw for read_csv. Here, the structure of mean is:\nmean(x, trim = 0, na.rm = FALSE, ...)\nBelow, we can see the descriptions of each argument. When we examine na.rm it states: “a logical evaluating to TRUE or FALSE indicating whether NA values should be stripped before the computation proceeds.”\nSo in other words, if a numeric column contains missing values and we try to calculate the mean of said column, when the mean function approaches a missing value, it simply doesn’t know what to do with it. This makes sense as a missing value could be anything (0, 1000, \\(\\pi\\), or anything else!). So instead of trying to guess what the value is, it just returns NA. To have it just omit the missing values to have the function return to us the sample mean, we need to run the code:\n\nmean(heart$AgeAtDeath,na.rm=T)\n\n[1] 70.53641\n\n\nNow we get a result from the function that makes more sense!\n\n\n1.7.2 Selecting Subsets of Columns\nLet’s say I have a large dataframe with lots of columns, as you might see in your own fields of study. But, for whatever analysis I’m wanting to do, I don’t need all of the columns, just a few. In such a case, it might be useful to subset the dataframe and select only the columns we need.\nHow do we go about doing this? Like many things in R, there are a few different ways to yield the same result, but I’m going to show you what I consider the most straightforward method, which uses the dplyr package.\nUsing the heart dataframe, suppose I want to create a new dataframe which only contains the last four columns: Chol_Status, BP_Status, Weight_Status, and Smoking_Status. To do this, we will use the select function from within the dplyr package.\n\nheart_status &lt;- heart |&gt;\n  select(Chol_Status,BP_Status,\n         Weight_Status,Smoking_Status)\n\nheart_status |&gt;\n  glimpse()\n\nRows: 5,209\nColumns: 4\n$ Chol_Status    &lt;chr&gt; NA, \"Desirable\", \"High\", \"High\", \"High\", \"Desirable\", \"…\n$ BP_Status      &lt;chr&gt; \"Normal\", \"High\", \"High\", \"Normal\", \"Optimal\", \"High\", …\n$ Weight_Status  &lt;chr&gt; \"Overweight\", \"Overweight\", \"Overweight\", \"Overweight\",…\n$ Smoking_Status &lt;chr&gt; \"Non-smoker\", \"Non-smoker\", \"Moderate (6-15)\", \"Non-smo…\n\n\nOkay, great! But what if we instead wanted to subset the heart dataframe by characteristics of the rows, instead? For example, let’s say in the new heart_status dataframe we just created, we want to create a new dataframe where we only have those participants whose Weight_Status is “Overweight.” To do this, we can now instead use the filter function which is also contained within the powerful and useful dplyr package:\n\nheart_status_ow &lt;- heart_status |&gt;\n  filter(Weight_Status == 'Overweight')\n\nIf you’re familiar with SQL, dplyr operates in much the same manner. So most anything we can do from a data wrangling perspective with SQL, we can also with dplyr.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "communicating_data.html#introduction",
    "href": "communicating_data.html#introduction",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nTelling a story with data through a visual medium is an incredibly powerful tool we as data scientists have to quickly and effectively disseminate information to a broad audience. When done effectively, data visualizations can engender an appreciation of both the data itself, as well as the medium by which it is being delivered.\nYou can probably think of instances where you have observed a really good (or really bad) data visualization. For instance, check out the below visualization:\n\n\n\n\n\n\n\n\n\nOr this one:\n\n\n\n\n\n\n\n\n\nOr (because I love baseball) this one https://twitter.com/i/status/1107706014655229953\nBut you’ve likely also seen some not so effective visualizations as well. The source of the ineffectiveness could stem from a myriad of sources, but in general, if it takes a reader more than a few seconds to understand what information the visualization is attempting to convey, then it is likely an ineffective method.\nPie charts are notorious for being ineffective:\n\n\n\n\n\n\n\n\n\nAs another example of a bad pie chart:"
  },
  {
    "objectID": "communicating_data.html#the-research-process",
    "href": "communicating_data.html#the-research-process",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "2.2 The Research Process",
    "text": "2.2 The Research Process\nData visualization is a piece of what I call the “research process.” The research process can be thought of as a somewhat more specific set of steps as part of the scientific method.\nThe process, in general, has the following steps:\n\nOverarching Question\nData Collection\nData Organization\nData Analysis\nData Communication\n\n\n2.2.1 Formulating a Question\nBefore we start analyzing data using all of the cool techniques you have learned or will learn in your data science studies (as well as those you’ll learn in this course!), we need a question which guides the study.\nFor example:\n\n“Which products tend to be purchased at the same time?”\n“What is it about our coffee shop that brings customers back?”\n“Which universities produce the most Major League Baseball lefthanded pitchers?”\n\nAnswering the question, in effect, is the goal. In my opinion, the clear articulation of the research question is perhaps the most critical piece of the research process.\n\n\n2.2.2 Gathering Data\nOnce we have our question clearly stated, we can then make a determination as to what specific data is necessary to answer said question.\nThis may involve querying databases and/or merging datasets from disparate sources. Or, alternatively, we may actually have to go collect the data from, say, human participants.\nFor instance, say my question is: “What is the relationship between time spent on TikTok and GPA among undergraduate students in Georgia?” I’m going to have to go collect information from these students since there is likely no other way for me to get it.\n\n\n2.2.3 Organizing the Data\nAs I am confident you have learned, the structure of the data, once collected, is incredibly important for the data analysis phase, specifically for use in software, like R or Python. For most all analytical functions in R, the data need to be organized in a “tidy” or “long” format.\nWhat this means is: every row is a unique observation and every column is a unique variable.\nUsing a subset of the famous mtcars dataset, the below table is organized in a tidy format as each vehicle has its own row and every column is a variable or characteristic of each vehicle:\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\n\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n\n\nDatsun 710\n22.8\n4\n108\n93\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n\n\nValiant\n18.1\n6\n225\n105\n\n\n\n\n\n\n\n2.2.4 Analyzing the Data\nOnce the collected data are in the appropriate format, we can then move into data analysis, of which data visualization is a major and important component!\nIt is here where we are using all of the analytical methods we have learned so far in order to answer the overarching question.\nThis could be something as simple as a t-test or something as complicated as support vector machines. The question guides us toward the methods and techniques available to us for appropriately answering the question.\n\n\n2.2.5 Communicating the Results\nFinally, once we have analyzed our data, the final step is effectively communicating the results.\nTo me, this is where exceptional data scientists can set themselves apart from other data scientists. It is expected that a data scientist can perform the analyses using whichever programming language. But, the best data scientists also know how to explain the results in an accessible way.\nData visualization almost certainly should be a component of data communication in all analyses.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Problems and Principles in Communicating Data</span>"
    ]
  },
  {
    "objectID": "communicating_data.html#a-model-of-communication",
    "href": "communicating_data.html#a-model-of-communication",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "2.3 A Model of Communication",
    "text": "2.3 A Model of Communication\nIn order for us to understand how to effectively communicate data using a visual medium, it may be useful to understand the communication process in general. As an example, suppose you are with a friend and you want to plan on going to dinner this coming weekend at a fancy new restaurant.\nHere, the source of information (or data source) is the thought in your brain: “Hey I think it would be fun to go to dinner at this new fancy restaurant with my good friend this coming weekend.”\nFrom there, you turn this thought into verbal words (the message) and communicate that with your friend with your voice (the transmitter).\nWhat often gets overlooked in verbal communication is the role of non-verbal communication. Your tone, your hand gestures, your eyes, and your posture can all affect the meaning of the words being verbalized. All of this can be considered noise affecting the quality of the transmission.\nThe final message arrives to your friend (the “receiver”) who represents the final destination of the original message.\nClearly, they may interpret it in the way that was intended (“my friend wants to do something fun this weekend…I’m in!”) or in a way that it wasn’t intended (“my friend’s low-energy tone makes me think they are asking out of obligation or guilt and not because they really want to go with me”).\nWe can visually assess this process:\n\n\n\n\n\nFrom Communicating Data with Tableau\n\n\n\n\nUsing this simple model, we can see how the quality of the signal, which is a function of the method of transmission as will as the information or data source, directly affects the quality of the received message.\nSo for us, this suggests that we need to use the right tools for our specific data to deliver a quality signal to our end users.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Problems and Principles in Communicating Data</span>"
    ]
  },
  {
    "objectID": "communicating_data.html#types-of-communication-problems",
    "href": "communicating_data.html#types-of-communication-problems",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "2.4 Types of Communication Problems",
    "text": "2.4 Types of Communication Problems\nI am confident that at some point in your life, you have run into a communication problem.\nAs an example from my own life, I was about 15 when AOL/MSN instant messenger became widely popular and high school sophomore Dr Brown was constantly running into communication issues with friends. This was one of the first times that text-based communication was widely used as a means of instant communication.\nPeople, myself included, were not “texting” the way that they talk and that lead to all sorts of issues.\nFor us in data visualization, we can categorize communication problems into three broad types:\n\nThe Technical Problem\nThe Semantic Problem\nThe Effectiveness Problem\n\n\n2.4.1 The Technical Problem\nThe technical problem can be assessed with a question: “How accurately can the symbols of communication be transmitted?”\nFor us, this has to do with things like number of pixels, aspect ratio, sound quality, etc.\nReally, it is anything which yields in an outcome in which the message’s receiver gets something other than what was originally designed/crafted.\nThis is sometimes an issue with using non-Instagram pictures in an Instagram post, without doing the appropriate resizing.\n\n\n2.4.2 The Semantic Problem\nThe semantic problem can be assessed with the question: “How precisely do the transmitted symbols convey the desired meaning?”\nIn data visualization, this can take lots of different forms. As one example, maybe we use an inappropriate visualization for our data type.\nIn the donut pie chart example, those data would have likely been more effectively visualized as a bar graph with descriptive axis titles.\nIt could also look like using symbols not necessarily understood by all audience members.\nFor example, if we wanted to plot team-level data for National Basketball Association (NBA) teams using the team logo instead of name, but our audience is a general audience, they might not be clear one what information is being conveyed.\n\n\n2.4.3 The Effectiveness Problem\nThe effectiveness problem can be assessed with the question: “How effectively does the received meaning affect conduct in the desired way?” or in other words: “So what?”\nUltimately, what we are attempting to do with visualizations is affect behavior in some form or fashion.\nIn the homeruns visualization, my “so what?” was the appreciation of how good of hitters the all-time greats were for such a long time.\nIn the bird density visualization, my “so what?” was connecting the intuitive idea that birds are not highly concentrated in high-altitude locations, like the Rocky Mountain west.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Problems and Principles in Communicating Data</span>"
    ]
  },
  {
    "objectID": "communicating_data.html#principles-of-communicating-data",
    "href": "communicating_data.html#principles-of-communicating-data",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "2.5 Principles of Communicating Data",
    "text": "2.5 Principles of Communicating Data\nIf we know that data visualization are useful and powerful tools for communicating information to broad audiences, and that we also know that there are problems we can encounter in doing so, it would be useful to have a general framework or principles for communicating data visually.\nThese principles are:\n\nKnow your goal\nUse the right data\nSelect suitable visualizations\nDesign for aesthetics\nChoose an effective medium and channel\nCheck the results\n\nLet’s discuss these in more depth.\n\n2.5.1 Know Your Goal\nClearly, understanding the goal of our visualization is important in deciding how to craft it. To understand the goal, we can ask ourselves a few questions:\n\nWho are you trying to communicate with? (specify the target audience)\nWhat do you want the audience to know? (specify the intended meaning)\nWhy? What do you want them to do about it? (specify the desired effect)\n\nIf you can’t answer any one of these questions, you should not proceed until you can.\n\n\n\n\n\nFrom Communicating Data with Tableau\n\n\n\n\n\n\n2.5.2 Use the Right Data\nClearly, in order for us to be able to achieve our goal, we need to ensure that we are using the “right” data. What is “right” is going to wildly vary depending on what the goal is.\nI would say generally, determining what is right can be done by asking the two questions:\n\nAre the data related/relevant to the goal?\nDo I have the right amount of data for the intended message to be effectively conveyed?\n\nFor example, suppose I want to build a visualization which shows how undergraduate data science students are performing in an introductory computing class.\nWe would first need to operationalize “student performance.” One way could be by looking at the overall score for the course.\nNext, we would need to decide how much data is right for our goal. Is one semester and one course sufficient? Or would we want multiple courses and multiple semesters? These questions should be answered before doing anything else!!\n\n\n2.5.3 Select Suitable Visualizations\nFor us to effectively communicate information, we must use appropriate visualizations. In general, we do this by first understanding the variable types that we are graphing. In general, we have:\n\nQuantitative Variables (precise numeric values)\nOrdinal Variables (categorical variables with inherent ordering)\nNominal Variables (categorical variables without inherent ordering)\n\nWhat is effective for quantitative variables likely won’t be as effective for nominal variables and vice versa. We will talk more specifically about effective techniques for each variable type as the semester progresses.\n\n\n2.5.4 Design for Aesthetics\nVisualizations can be designed with many or few aesthetic elements, such as watermarks or annotations or different font colors, etc.\nThese can be used to improve (or hinder) data visualizations. Let’s talk about a few different poor aesthetic choices:\n\nPoor Color Schemes\nDistracting Fonts\nLots of Different Fonts\nSloppy Alignment\nPoor use of Angled Labels\nThick Borders/Grid Lines\nUnnecessary/Useless Images\nUsing the Default Graphical Settings without Thought\n\n\n\n\n\n\nFrom Communicating Data with Tableau\n\n\n\n\n\n\n2.5.5 Choose an Effective Medium and Channel\nWhen we discuss a “medium” what we are referring to is how the data visualization is to be communicated. Will it be:\n\nStandalone graphics or narrated?\nStatic, interactive, animated, or combined?\nIf narrated: recorded, live, or both?\nIf live: remote, in person, or both?\nIn all cases: broadcast, directed, or both?\n\nThese choices are going to affect the “channel” or audience.\n\n\n\n\n\nFrom Communicating Data with Tableau\n\n\n\n\n\n\n2.5.6 Check the Results\nHaving feedback loops is a good life skill but is especially useful in data science and data visualization. This helps us know to what degree our efforts yielded the intended result.\nTo do this, we can ask questions like:\n\nDid the audience receive the message at all? Or who did and who didn’t?\nDid the audience interpret the data message in the way you intended?\nDid the audience react in the way you wanted them to react?\n\nThe answers to these questions can be useful in aiding the development of our visualization and data science skills.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Problems and Principles in Communicating Data</span>"
    ]
  },
  {
    "objectID": "communicating_data.html#summary",
    "href": "communicating_data.html#summary",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "2.6 Summary",
    "text": "2.6 Summary\nIn sum, while knowing how to create various types of visualizations is a wonderful skill, it is better to know how to create effective visualizations.\nThroughout this course, we will explore specific ways of doing this very thing and also think critically about what effectiveness means in specific situations.\nNext, let’s learn how we can use R, and specifically the ggplot2 package, to build quality visualizations to answer research questions…",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Problems and Principles in Communicating Data</span>"
    ]
  },
  {
    "objectID": "how_much.html#introduction",
    "href": "how_much.html#introduction",
    "title": "3  Communicating How Much",
    "section": "",
    "text": "“How much money did we earn this past quarter?”\n“How much carbon dioxide is in the atmosphere?”\n“How much time do undergraduate students in Georgia spend on social media sites per day?”\n\n\n\n\nA sales order generating revenues of $95\nA shipment weighing 5.2 pounds\nA flight covering a distance of 2,408 miles",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Communicating How Much</span>"
    ]
  },
  {
    "objectID": "how_much.html",
    "href": "how_much.html",
    "title": "3  Communicating How Much",
    "section": "",
    "text": "3.1 Introduction\nIn this section, we are going to be learning about existing methods which help us visually communicate, “How Much?”\n“How much?” types of visualizations make use of quantitative variables, which are like:\nIn other words, we will be focusing on questions which involve a single (or univariate) quantitative variable.\nQuantitative variables could be characteristics like revenue, weight, distance, and time, among many, many others. Generally, here, our data source would need to be in aggregate form, so that a single record exists. For instance:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Communicating How Much</span>"
    ]
  },
  {
    "objectID": "how_much.html#nyc-garbage-dataset-example",
    "href": "how_much.html#nyc-garbage-dataset-example",
    "title": "3  Communicating How Much",
    "section": "3.2 NYC Garbage Dataset Example",
    "text": "3.2 NYC Garbage Dataset Example\nLet’s use NYC Garbage Data as an example. These data represent the amount of garbage (the less fancy term for “refuse”), in tons, collected each month of the year, in each of the boroughs and community districts in the city.\nSuppose we wanted to know, “How does the amount of garbage/refuse (in tons) that the NYC Department of Sanitation reportedly collected from each borough compare during September 2011?”\nLet’s see how we can accomplish this!\nFirst, we have to subset the data to our specific time parameters (September 2011). Don’t worry about the warning message if you get one.\n\nlibrary(tidyverse)\nlibrary(readxl)\n## To answer this question, let's first read in the data ##\nnyc &lt;- read_xlsx(\"Communicating How Much/NYC Trash Data.xlsx\")\n## Subset to September 2011 ##\nnyc_sept11 &lt;- nyc |&gt;\n  filter(MONTH == 9 & YEAR == 2011)\n## Sum up REFUSETONSCOLLECTED variable by Borough ##\ntrash_tot &lt;- nyc_sept11 |&gt;\n  group_by(BOROUGH) |&gt;\n  summarize(Sum_Trash = sum(REFUSETONSCOLLECTED))\n## Take a glimpse of the result ##\nprint(trash_tot)\n\n# A tibble: 5 × 2\n  BOROUGH       Sum_Trash\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Bronx            37735.\n2 Brooklyn         71074.\n3 Manhattan        38066.\n4 Queens           64365.\n5 Staten Island    17885.\n\n\nOur result here is the exact data we need to answer our above question! We have, by borough, the total amount of garbage produced, in tons, during September 2011. Now the question is: what tools and techniques do we have to turn this tabular data into a nice visualization? Well from the Communicating Data with Tableau text, we can see several examples of how to do this, all of which can be done with ggplot2!\n\n\n\n\n\n\n\n\n\nFor us, let’s start with the well-known bar chart!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Communicating How Much</span>"
    ]
  },
  {
    "objectID": "how_much.html#building-bar-charts-to-communicate-how-much",
    "href": "how_much.html#building-bar-charts-to-communicate-how-much",
    "title": "3  Communicating How Much",
    "section": "3.3 Building Bar Charts to Communicate “How Much”",
    "text": "3.3 Building Bar Charts to Communicate “How Much”\nTo build a bar chart using ggplot2, we use the function geom_bar to help us out:\n\ntrash_tot |&gt;\n  ggplot(aes(x=BOROUGH,y=Sum_Trash)) +\n  geom_bar(stat='identity')\n\n\n\n\n\n\n\n\nGreat! We have a visualization to compare “how much?” But what are some problems that you observe? I notice a few right away:\n\nPoor use/no use of axis titles and plot titles (How does anyone know what these data represent or what time period they represent?)\nThe comparison between boroughs isn’t as straightforward as it could be due to the bars being ordered in alphabetical rather than ascending or descending order.\nThe default color palette is less than desirable.\n\nLet’s see how we can solve each of these problems by adding additional code to our base visualization:\n\n3.3.1 Including/Modifying Axis and Overall Titles\n\ntrash_tot |&gt;\n  ggplot(aes(x=BOROUGH,y=Sum_Trash)) +\n  geom_bar(stat='identity') +\n  labs(x = \"NYC Borough\",\n       y = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collectd in NYC by Borough\",\n       subtitle = \"September 2011\")\n\n\n\n\n\n\n\n\n\n\n3.3.2 Reordering the Bars in Descending Order Based on Numeric Value\n\ntrash_tot |&gt;\n  ggplot(aes(x=reorder(BOROUGH,-Sum_Trash),y=Sum_Trash)) +\n  geom_bar(stat='identity') +\n  labs(x = \"NYC Borough\",\n       y = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collectd in NYC by Borough\",\n       subtitle = \"September 2011\")\n\n\n\n\n\n\n\n\n\n\n3.3.3 Changing the Color of the Bars and Overall Theme\n\ntrash_tot |&gt;\n  ggplot(aes(x=reorder(BOROUGH,-Sum_Trash),y=Sum_Trash)) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  labs(x = \"NYC Borough\",\n       y = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collectd in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nNotice how this final visualization is displaying the exact same information as our base visualization, but in a manner where audiences can more readily glean the information being conveyed (not to mention the improved aesthetics!).\n\n\n3.3.4 Ordered Horizontal Bar Chart\nNote, it is also very common to display bar charts in a horizontal manner rather than vertical. To do this, we simply change our x and y arguments in the global ggplot function and remove the hyphen from the reorder function to still display the bars in descending order:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collectd in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Communicating How Much</span>"
    ]
  },
  {
    "objectID": "how_much.html#building-dot-charts-to-communicate-how-much",
    "href": "how_much.html#building-dot-charts-to-communicate-how-much",
    "title": "3  Communicating How Much",
    "section": "3.4 Building Dot Charts to Communicate “How Much”",
    "text": "3.4 Building Dot Charts to Communicate “How Much”\nThe ordered vertical and horizontal bar charts are really useful tools for comparing “how much” but certainly they aren’t the only tools.\nAnother tool, called the “dot chart” is sometimes preferred to the two methods previously discussed seeing as the eye may be overwhelmed by the bars. We are really just comparing values.\nIn essence, we only need the “top” of the bars, not the whole thing.\nUsing the basic ggplot2 syntax we have already developed for the bar charts, we can easily convert our bar charts into dot charts:\n\n## Vertical Dot Chart ##\ntrash_tot |&gt;\n  ggplot(aes(x=reorder(BOROUGH,-Sum_Trash),y=Sum_Trash)) +\n  geom_point(color='blue',fill='blue') +\n  labs(x = \"NYC Borough\",\n       y = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collectd in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nNotice something about these dots…they’re tiny! How can we control the size of the dots? We can use the size argument within the geom_point function. The default value is 1.5. We can increase or decrease this value based on our needs! Let’s try size=3:\n\n3.4.1 Controlling Point Size\n\ntrash_tot |&gt;\n  ggplot(aes(x=reorder(BOROUGH,-Sum_Trash),y=Sum_Trash)) +\n  geom_point(color='blue',fill='blue',size=3) +\n  labs(x=\"NYC Borough\",\n       y=\"Total Refuse Collected (in tons)\",\n       title=\"Trash Collected in NYC by Borough\",\n       subtitle=\"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nThis is better! And just like with the bar chart, we can convert our vertical dot chart into a horizontal dot chart with a small modification to the ggplot function’s code in the exact same manner as before:\n\n\n3.4.2 Ordered Horizontal Dot Chart\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_point(color='blue',fill='blue',size=3) +\n  labs(y=\"NYC Borough\",\n       x=\"Total Refuse Collected (in tons)\",\n       title=\"Trash Collected in NYC by Borough\",\n       subtitle=\"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nOne potential limitation of the dot chart, as it stands, is that even though we only care about the dots themselves, the eye may need help in moving from the y-axis to the dot, especially when the values associated with the dots are large (in a relative sense).\nInstead of including a whole bar, what if we included just a dashed line going from the borough name to the dot?\nWe can do this in multiple ways, but one straightforward way is to add another geom function! This time, we can use the geom_segment function to draw a line segement.\nNotice in the geom_segment function, we have to specify when the line segments begin and end in terms of their x and y coordinates. We’ve already specified where x and y start in the global ggplot function: at the value of the point and the borough itself, respectively. Since we are drawing horizontal lines, the value of y doesn’t change. Thus, yend=BOROUGH. Since x starts at the value of the point and since we are again drawing horizontal lines, xend=0. We can also control the color and linetype as well.\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_point(color='blue',fill='blue',size=3) +\n  geom_segment(aes(yend=BOROUGH),xend=0,color='gray',\n               linetype='dashed') +\n  labs(y=\"NYC Borough\",\n       x=\"Total Refuse Collected (in tons)\",\n       title=\"Trash Collected in NYC by Borough\",\n       subtitle=\"September 2011\") +\n  theme_classic()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Communicating How Much</span>"
    ]
  },
  {
    "objectID": "how_much.html#your-turn",
    "href": "how_much.html#your-turn",
    "title": "3  Communicating How Much",
    "section": "3.5 Your Turn!",
    "text": "3.5 Your Turn!\nNow, using the Lahman package and the Batting and People datasets within that package, suppose I want to know who the top 10 homerun hitters during the 2022 Major League Baseball regular season were and how many homeruns they hit?\n\nCreate an ordered horizontal barchart to answer this question.\nCreate an ordered vertical dot chart to answer this question.\nHow else might this visualization be modified to better communicate the story we are trying to tell?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Communicating How Much</span>"
    ]
  },
  {
    "objectID": "legends_colors_fonts.html",
    "href": "legends_colors_fonts.html",
    "title": "4  Using Legends, Colors, Fonts, and Axes to Improve Visualizations",
    "section": "",
    "text": "4.1 Introduction\nIn the last section, we learned how to use bar charts and dot charts to help communicate “how much” of something that has been observed between categorical groups.\nAs we saw, we can make small modifications to our ggplot2 code to substantially improve the interpretability and aesthetic quality of the visualization using things like color and plot themes.\nIn this section, we’re going to take that a step further by learning how we can leverage ggplot2 code to create and modify legends and elements of our axes, use a variety of colors, color palettes, text and fonts.\nLet’s begin by using some text to improve our NYC Garbage visualization:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Using Legends, Colors, Fonts, and Axes to Improve Visualizations</span>"
    ]
  },
  {
    "objectID": "legends_colors_fonts.html#annotating-visualizations-with-text",
    "href": "legends_colors_fonts.html#annotating-visualizations-with-text",
    "title": "4  Using Legends, Colors, Fonts, and Axes to Improve Visualizations",
    "section": "4.2 Annotating Visualizations with Text",
    "text": "4.2 Annotating Visualizations with Text\nRecall where we left off with our horizontal bar chart:\n\n\n\n\n\n\n\n\n\nWe can generally see from this visualization that Staten Island produced the least amount of garbage for the month of September 2011 and Brooklyn produced the most.\nWe can also generally determine the amount of garbage collected. For instance, Staten Island was generally around 20K tons, whereas Queens and Brooklyn were somewhat more than 60K tons.\nIt might be helpful if we put the actual amount associated with each borough on the bars themselves to increase the amount of information the reader can glean from the visualization.\nTo do this, we can make use of a new geom: geom_text\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=Sum_Trash)) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nOkay cool! But what is the most obvious problem?\nThe label is centered at the end of the bar, making the text difficult to read. We can change the justification of the text by using the hjust argument. This argument allows us to horizontally adjust the alignment of our text labels. hjust can assume a value between 0 and 1 with a value of 0 implying complete right justification and a value of 1 implying complete left justification.\nNote, hjust and its counterpart vjust can assume values outside of this interval if we want to move our labels further away from the point they are anchored upon.\nLet’s try hjust = 1 to move the text labels inside of the bars:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=Sum_Trash),hjust = 1) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nLooks better! But now notice that the label itself is rounded to just one decimal place, which seems unusual. We can fix this, and also move the label more inside of the bar, directly within geom_text\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),hjust=1.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\n\n4.2.1 Modifying Font Characteristics\nOur visualization is much improved over what we had originally created! But consider the font style. Right now, our visualization uses a sans serif style font in a black color by default.\nWhat if we wanted to change that?\n\n4.2.1.1 Font Family\nWhile we can specify a wide variety of fonts, the main three guaranteed to work everywhere in a ggplot2 visualization are sans (default), serif (like Times New Roman), and mono (like typewriter font):\n\ndf &lt;- data.frame(x = 1, y = 3:1, family = c(\"sans\", \"serif\", \"mono\"))\ndf |&gt;\n  ggplot(aes(x, y)) + \n  geom_text(aes(label = family, family = family))\n\n\n\n\n\n\n\n\n\n\n4.2.1.2 Font Face\nWe can also make our fonts, bold, italic, bold.italic, or plain:\n\ndf &lt;- data.frame(x = 1:4, fontface = c(\"plain\", \"bold\", \"italic\", \"bold.italic\"))\ndf |&gt;\n  ggplot(aes(1, x)) + \n  geom_text(aes(label = fontface, fontface = fontface))\n\n\n\n\n\n\n\n\n\n\n4.2.1.3 Font Color\nWe can modify the color of our text uniformly by using the color argument within the geom_text function by either using a named color (see the colors() function for the full list) or using hex codes:\n\n## Salmon Font ##\ndf |&gt;\n  ggplot(aes(1, x)) + \n  geom_text(aes(label = fontface, fontface = fontface),\n            color='salmon')\n\n\n\n\n\n\n\n\n\n## Manchester City Light Blue ##\ndf |&gt;\n  ggplot(aes(1, x)) + \n  geom_text(aes(label = fontface, fontface = fontface),\n            color = \"#6CABDD\")\n\n\n\n\n\n\n\n\nFor our NYC Garbage example, suppose I want the text to serif style, with a bold italic font face, and in Atlanta Braves red (hex code #CE1141):\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=1.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Using Legends, Colors, Fonts, and Axes to Improve Visualizations</span>"
    ]
  },
  {
    "objectID": "legends_colors_fonts.html#modifying-axes-elements",
    "href": "legends_colors_fonts.html#modifying-axes-elements",
    "title": "4  Using Legends, Colors, Fonts, and Axes to Improve Visualizations",
    "section": "4.3 Modifying Axes Elements",
    "text": "4.3 Modifying Axes Elements\n\n4.3.1 Axis Length\nStill using our NYC Garbage example, let’s suppose I’d rather have the text labels outside of the bars to the right rather than inside the bars to the left. Remember, we can make a simple change to our hjust argument to do this:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nWhoops! Now I can’t see Brooklyn’s label! It’s being truncated by the size of our viewing window.\nOne way this can be modified is by increasing the x-axis length. We can do this by using the limits argument within the scale_x_continuous function.\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic() +\n  scale_x_continuous(limits = c(0,75000))\n\n\n\n\n\n\n\n\nAwesome! That solved the problem!\n\n\n4.3.2 Modifying Tick Marks\nNotice that our tick marks on the x-axis are in increments of 20,000.\nWhat if we want to increase the number of tick marks to be in increments of 10,000 instead? We can again use scale_x_continuous this time making use of the breaks argument:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic() +\n  scale_x_continuous(limits = c(0,75000),\n                     breaks = seq(0,80000,by=10000))\n\n\n\n\n\n\n\n\n\n\n4.3.3 Formatting Tick Mark Labels\nIn the above visualization, we note that each tick mark represents a unit measured in the thousands as we can see by the three trailing zeros in each tick mark label.\nWe may perhaps wish to represent “thousand” by the common label “K” so that 10000 = 10K.\nTo do this using ggplot2, we can once again use the very useful scale_x_continuous function, now adding a new element of functionality – the labels function:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic() +\n  scale_x_continuous(limits = c(0,75000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))\n\n\n\n\n\n\n\n\nNotice in the above code, we are using the label_number function from the scales package to add the “K” suffix to the labels and scale (or multiply) the numeric labels by \\(1/1000\\).\n\n\n4.3.4 Modifying Axis Font Styles\nWe already learned how to modify font styles in the context of geom_text, but we can use the exact same logic and syntax to modify font in our axes as well as titles!\nSo suppose we want our tick mark labels and axis titles to match the formatting of our data labels. We can do this using the theme function:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash))) +\n  geom_bar(stat='identity',color='black',fill='white') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic',\n                                   color = '#CE1141'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic',\n                                    color = '#CE1141'),\n        axis.text.y = element_text(family = 'serif',\n                                   face = 'bold.italic',\n                                   color = '#CE1141'),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic',\n                                    color = '#CE1141')) +\n  scale_x_continuous(limits = c(0,75000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Using Legends, Colors, Fonts, and Axes to Improve Visualizations</span>"
    ]
  },
  {
    "objectID": "legends_colors_fonts.html#legends",
    "href": "legends_colors_fonts.html#legends",
    "title": "4  Using Legends, Colors, Fonts, and Axes to Improve Visualizations",
    "section": "4.4 Legends",
    "text": "4.4 Legends\nRather than having the bars all be a uniform color (white in this case), suppose I want to have the colors of the bars differ by the particular borough they’re representing. We can do so with a very slight modification to the existing code.\nIn the global ggplot function, let’s add fill=BOROUGH:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic')) +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))\n\n\n\n\n\n\n\n\nCool, right? But now, we don’t really have a need for the y-axis labels. We can supress those and the tick marks using the theme function:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank()) +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))\n\n\n\n\n\n\n\n\nNotice the legend title is all caps. We can modify the legend title in the labs function:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank()) +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))\n\n\n\n\n\n\n\n\nWe can also control the position of the legend within the visualization through the legend.position argument within the theme function (default is legend.position='right'):\n\n## Top ##\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank(),\n        legend.position = \"top\") +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))\n\n\n\n\n\n\n\n## Bottom ##\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank(),\n        legend.position = \"bottom\") +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3))\n\n\n\n\n\n\n\n\n\n4.4.1 Changing Color Palettes\n\n4.4.1.1 Viridis\nIn the above plot, the generated colors are the defaults. We can change the palette we use either manually or by using palettes within packages such as viridis, which provides colorblind-friendly palettes.\n\nlibrary(viridis)\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank(),\n        legend.position = \"bottom\") +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3)) +\n  scale_fill_viridis(discrete = T)\n\n\n\n\n\n\n\n\nWithin scale_fill_viridis, we have eight different palettes we can specify (A - H). So for example, if I want to employ the “turbo” option (“H”):\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank(),\n        legend.position = \"bottom\") +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3)) +\n  scale_fill_viridis(discrete = T,\n                     option = \"H\")\n\n\n\n\n\n\n\n\n\n\n4.4.1.2 RColorBrewer\nThe RColorBrewer package also provides a nice list of palettes we can use to customize our visualization. Let’s take a look at all of our possibilities:\n\nlibrary(RColorBrewer)\nprint(brewer.pal.info)\n\n         maxcolors category colorblind\nBrBG            11      div       TRUE\nPiYG            11      div       TRUE\nPRGn            11      div       TRUE\nPuOr            11      div       TRUE\nRdBu            11      div       TRUE\nRdGy            11      div      FALSE\nRdYlBu          11      div       TRUE\nRdYlGn          11      div      FALSE\nSpectral        11      div      FALSE\nAccent           8     qual      FALSE\nDark2            8     qual       TRUE\nPaired          12     qual       TRUE\nPastel1          9     qual      FALSE\nPastel2          8     qual      FALSE\nSet1             9     qual      FALSE\nSet2             8     qual       TRUE\nSet3            12     qual      FALSE\nBlues            9      seq       TRUE\nBuGn             9      seq       TRUE\nBuPu             9      seq       TRUE\nGnBu             9      seq       TRUE\nGreens           9      seq       TRUE\nGreys            9      seq       TRUE\nOranges          9      seq       TRUE\nOrRd             9      seq       TRUE\nPuBu             9      seq       TRUE\nPuBuGn           9      seq       TRUE\nPuRd             9      seq       TRUE\nPurples          9      seq       TRUE\nRdPu             9      seq       TRUE\nReds             9      seq       TRUE\nYlGn             9      seq       TRUE\nYlGnBu           9      seq       TRUE\nYlOrBr           9      seq       TRUE\nYlOrRd           9      seq       TRUE\n\n\nThe first set of palettes (labeled “div”) are best for quantitative data.\nThe third set (labeled “seq”) are best for quantitative data with clear extremes.\nThe middle set (labeled “qual”) is what would be most appropriate for us: the qualitative palettes.\nLet’s try Pastel1:\n\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank(),\n        legend.position = \"bottom\") +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3)) +\n  scale_fill_brewer(palette = \"Pastel1\")\n\n\n\n\n\n\n\n\n\n\n4.4.1.3 Custom Palettes\nBeing able to use existing color palettes in R packages like viridis and RColorBrewer are nice! But there may be instances where we need to use a custom palette (consider colors for branding!).\nTo do this, we will employ the scale_fill_manual function after creating a vector called borough_colors which specifies which borough is assigned which specific color. Note, we can also use hex colors here rather than these specific named colors.\n\nborough_colors &lt;- c(\"Bronx\" = 'red',\n                    \"Brooklyn\" = 'blue',\n                    \"Manhattan\" = \"orange\",\n                    \"Queens\" = \"yellow\",\n                    \"Staten Island\" = 'violet')\ntrash_tot |&gt;\n  ggplot(aes(x=Sum_Trash,y=reorder(BOROUGH,Sum_Trash),fill=BOROUGH)) +\n  geom_bar(stat='identity',color='black') +\n  geom_text(aes(label=round(Sum_Trash)),family='serif',\n            fontface='bold.italic',color='#CE1141',hjust=-0.25) +\n  labs(y = \"NYC Borough\",\n       x = \"Total Refuse Collected (in tons)\",\n       title = \"Trash Collected in NYC by Borough\",\n       subtitle = \"September 2011\",\n       fill = \"Borough\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(family = 'serif',\n                                   face = 'bold.italic'),\n        axis.title.x = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.text.y = element_blank(),\n        axis.title.y = element_text(family = 'serif',\n                                    face = 'bold.italic'),\n        axis.ticks.y = element_blank(),\n        legend.position = \"bottom\") +\n  scale_x_continuous(limits = c(0,80000),\n                     breaks = seq(0,80000,by=10000),\n                     labels = scales::label_number(suffix = \"K\",\n                                                   scale = 1e-3)) +\n  scale_fill_manual(values = borough_colors)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Using Legends, Colors, Fonts, and Axes to Improve Visualizations</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction to R Programming",
    "section": "",
    "text": "1.1 Why Use R?\nYou may be asking yourself, out of all of the possible visualization softwares which exist, why should I spend time learning and using R?\nGreat question!\nR is a useful tool and worthwhile to learn for several reasons:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R Programming</span>"
    ]
  },
  {
    "objectID": "communicating_data.html",
    "href": "communicating_data.html",
    "title": "2  Problems and Principles in Communicating Data",
    "section": "",
    "text": "2.1 Introduction\nTelling a story with data through a visual medium is an incredibly powerful tool we as data scientists have to quickly and effectively disseminate information to a broad audience. When done effectively, data visualizations can engender an appreciation of both the data itself, as well as the medium by which it is being delivered.\nYou can probably think of instances where you have observed a really good (or really bad) data visualization. For instance, check out the below visualization:\nOr this one:\nOr (because I love baseball) this one https://twitter.com/i/status/1107706014655229953\nBut you’ve likely also seen some not so effective visualizations as well. The source of the ineffectiveness could stem from a myriad of sources, but in general, if it takes a reader more than a few seconds to understand what information the visualization is attempting to convey, then it is likely an ineffective method.\nPie charts are notorious for being ineffective:\nAs another example of a bad pie chart:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Problems and Principles in Communicating Data</span>"
    ]
  },
  {
    "objectID": "variation.html",
    "href": "variation.html",
    "title": "5  Communicating Variation",
    "section": "",
    "text": "5.1 Introduction\nOne of the fundamental concepts in data science and statistics is that of variability.\nFor instance, not every Major League Baseball team wins the same number of games during a given regular season. The value, total number of wins in this case, varies from team to team.\nA goal in data science and statistics is to identify assignable reasons (not necessarily causal reasons) which can help us explain the variability we are observing. We generally call this “modeling.”\nHowever, the conclusions drawn from models may not necessarily be easily disseminated to a broad audience.\nThis is to say, visualizations may be effective tools we can use to visually communicate variability.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Communicating Variation</span>"
    ]
  },
  {
    "objectID": "variation.html#major-league-baseball-strikeout-example",
    "href": "variation.html#major-league-baseball-strikeout-example",
    "title": "5  Communicating Variation",
    "section": "5.2 Major League Baseball Strikeout Example",
    "text": "5.2 Major League Baseball Strikeout Example\nSuppose I want to see how the average number of strikeouts per nine innings pitched (SO/9) MLB pitchers have thrown has changed, if at all, from the 1910 season to the 2023 season.\nLet’s also focus on pitchers who have thrown more than 15 innings to avoid including position players who may occassionally be called on to pitch in lopsided games.\nWe can make use of the Lahman package to get the data we need and then use the dplyr package to get it into the right format.\n\nlibrary(tidyverse)\nso9 &lt;- Lahman::Pitching |&gt;\n  filter(between(yearID,1910,2023) & (IPouts/3) &gt;= 15) |&gt;\n  mutate(SO9 = SO/(IPouts/3)*9) |&gt;\n  group_by(yearID) |&gt;\n  summarize(Mean_SO9 = mean(SO9,na.rm=T))\n\nso9 |&gt;\n  glimpse()\n\nRows: 113\nColumns: 2\n$ yearID   &lt;int&gt; 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1…\n$ Mean_SO9 &lt;dbl&gt; 3.750483, 3.805158, 3.828411, 3.742237, 3.847999, 3.729206, 3…\n\n\nTo be clear about what the above code is doing:\n\nWe are loading the tidyverse package which includes the dplyr package.\nWe are taking the Pitching data from the Lahman package and filtering it to include only:\n\nData from the 1910 season to the 2023 season and\nData from pitchers who have thrown at least 15 innings.\n\nWe are creating a new variable SO9 which is the average number of strikeouts per nine innings pitched using the mutate function.\nWe are grouping the data by yearID and calculating the mean SO9 for each year.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Communicating Variation</span>"
    ]
  },
  {
    "objectID": "variation.html#communicating-variation-using-a-time-series-plot",
    "href": "variation.html#communicating-variation-using-a-time-series-plot",
    "title": "5  Communicating Variation",
    "section": "5.3 Communicating Variation using a Time Series Plot",
    "text": "5.3 Communicating Variation using a Time Series Plot\nOkay great! Now that the data are in the right format, we can shift our focus to ggplot2. The specific visualization we will use in this case is one you’ve likely seen before: the time series plot.\nThis visualization generally consists of a line plot with time on the x-axis (yearID for us) and the variable of interest on the y-axis (Mean_SO9 for us).\nTo create this type of visualizaiton with ggplot2, we will make use of a new geom: geom_line\n\nso9 |&gt;\n  ggplot(aes(x=yearID,y=Mean_SO9)) +\n  geom_point() +\n  geom_line() +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2020 Regular Seasons\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nAs we can see, SO/9 has steadily increased over time with notable decreases during the first World War/Flu Pandemic and right around baseball becoming integrated.\nThe results make sense: pitching has become much more specialized over time and of course, the athletes are also training much differently than in the past.\n\n5.3.0.1 Annotating Time Series Plots\nIn the above plot, we can see the general trend of SO/9 over time. However, we may want to highlight specific years, such as the years with the highest and lowest SO/9 values.\nTo achieve this, we will first identify which years had the highest and lowest SO/9 values and save those values to their own dataframe:\n\nminmax &lt;- so9 |&gt;\n  filter(Mean_SO9 == min(Mean_SO9) | Mean_SO9 == max(Mean_SO9))\n\nminmax |&gt;\n  glimpse()\n\nRows: 2\nColumns: 2\n$ yearID   &lt;int&gt; 1924, 2020\n$ Mean_SO9 &lt;dbl&gt; 2.656673, 9.252482\n\n\nNow we can plot by using the geom_text function to add text to the original plot, much like we did in Chapter 4:\n\nso9 |&gt;\n  ggplot(aes(x=yearID,y=Mean_SO9)) +\n  geom_point() +\n  geom_line() +\n  geom_text(aes(label=Mean_SO9),data=minmax) +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nWe observe a couple of problems here:\n1. We have too many digits in our labels; we need to round.\n2. We need to adjust the position of our labels so they don't overlap with the line plot.\nFortunately, we can fix both problems with relative ease:\n\nso9 |&gt;\n  ggplot(aes(x=yearID,y=Mean_SO9)) +\n  geom_point() +\n  geom_line() +\n  geom_text(aes(label=round(Mean_SO9,2)),\n            vjust = -1,data=minmax) +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic() +\n  scale_y_continuous(limits=c(2,11))\n\n\n\n\n\n\n\n\nGreat! We have nice data labels on our visualization now! But we are now encountering another problem: what in the world do the labels represent?\nAs of right now, they are numbers on a graph with no context. We need to add some context to these labels to make them more interpretable.\nLet’s create a short sentence for each label that explains what the label represents by modifying our minmax dataframe:\n\nminmax &lt;- minmax |&gt;\n  mutate(label = case_when(Mean_SO9 == min(Mean_SO9) ~ paste(yearID,\"Lowest SO/9\\nin 1910-2023\"),\n                           Mean_SO9 == max(Mean_SO9) ~ paste(yearID,\"Highest SO/9\\nin 1910-2023\"))\n  )\n\nminmax |&gt;\n  glimpse()\n\nRows: 2\nColumns: 3\n$ yearID   &lt;int&gt; 1924, 2020\n$ Mean_SO9 &lt;dbl&gt; 2.656673, 9.252482\n$ label    &lt;chr&gt; \"1924 Lowest SO/9\\nin 1910-2023\", \"2020 Highest SO/9\\nin 1910…\n\n\nCool! So let’s now add these improved labels to our plot:\n\nso9 |&gt;\n  ggplot(aes(x=yearID,y=Mean_SO9)) +\n  geom_point() +\n  geom_line() +\n  geom_text(aes(label=label),\n            vjust = -1,data=minmax) +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic()  +\n  scale_y_continuous(limits=c(2,12),\n                     breaks = seq(1,13)) +\n  scale_x_continuous(limits = c(1910,2027))\n\n\n\n\n\n\n\n\nWe can also use a great package called ggrepel to help us avoid overlapping labels. This package is not included in the tidyverse package, so we will need to install it separately:\n\nlibrary(ggrepel)\nso9 |&gt;\n  ggplot(aes(x=yearID,y=Mean_SO9)) +\n  geom_point() +\n  geom_line() +\n  geom_label_repel(aes(label=label),\n                   family='serif',\n                   color='turquoise',\n                   fontface='bold',\n                   size=3,\n                   nudge_y = 1,\n                   alpha = 0.8,\n                   data=minmax) +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic()  +\n  scale_y_continuous(limits=c(2,12),\n                     breaks = seq(1,13)) +\n  scale_x_continuous(limits = c(1910,2027))\n\n\n\n\n\n\n\n\nNotice in the above geom_label_repel code, I used alpha and nudge_y. The alpha argument controls the transparency of the labels (0 meaning completely invisible and 1 meaning completely opaque), while the nudge_y argument controls the vertical position of the labels (nudge_y=1 means push the label up 1 unit along the y-axis).\nOverall, we have added a little more context to our existing plot by using techniques largely familiar to us from previous lessons!\nBut what is a primary limitation of this plot? It communicates variability across the years but not within the years.\nConsequently, we can’t see how the within-year variability has changed over time, which may be useful for us to know! There are a few different options we can employ to help solve this problem:\n\n\n5.3.1 Time Series Plot with Standard Errors\nFirst, we can plot not only the mean value for each year, but we can also plot the standard errors of the means. This will give us a sense of how much the mean value is varying from year to year.\nTo do this, we will reaggregate our data now using the rstatix package in order to obtain the standard errors of the means.\n\nlibrary(rstatix)\nso9 &lt;- Lahman::Pitching |&gt;\n  filter(between(yearID,1910,2023) & (IPouts/3) &gt;= 15) |&gt;\n  mutate(SO9 = SO/(IPouts/3)*9) |&gt;\n  group_by(yearID) |&gt;\n  get_summary_stats(SO9,type='full') |&gt;\n  select(yearID,mean,se)\n\nso9 |&gt;\n  glimpse()\n\nRows: 113\nColumns: 3\n$ yearID &lt;int&gt; 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 192…\n$ mean   &lt;dbl&gt; 3.750, 3.805, 3.828, 3.742, 3.848, 3.729, 3.648, 3.342, 2.792, …\n$ se     &lt;dbl&gt; 0.099, 0.091, 0.091, 0.097, 0.079, 0.071, 0.083, 0.084, 0.076, …\n\n\nNow that we have the standard errors of the means, we can plot them using geom_errorbar in ggplot2.\n\nso9 |&gt;\n  ggplot(aes(x=yearID,y=mean)) +\n  geom_point() +\n  geom_errorbar(aes(ymin=mean-se,ymax=mean+se)) +\n  geom_line() +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nLooks pretty good! But what’s the problem?\nPrimarily, because we have so many seasons (big x-axis) and so many pitchers in a given season (big \\(n\\) within a given year), the standard errors are very small. This makes it difficult to see the standard errors on the plot.\nTo get around this issue, it may be preferable to use boxplots rather than standard errors to represent the within-year variation.\nHowever, to visualize boxplots, the data must be in its raw form (i.e., each row represents an individaul pitcher in a given season). To do this, we simply won’t perform any grouping operation:\n\nso9 &lt;- Lahman::Pitching |&gt;\n  filter(between(yearID,1910,2023) & (IPouts/3) &gt;= 15) |&gt;\n  mutate(SO9 = SO/(IPouts/3)*9)\n\nso9 |&gt;\n  glimpse()\n\nRows: 34,891\nColumns: 31\n$ playerID &lt;chr&gt; \"adamsba01\", \"albercy01\", \"amesre01\", \"anderwi01\", \"arellfr01…\n$ yearID   &lt;int&gt; 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1910, 1…\n$ stint    &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ teamID   &lt;fct&gt; PIT, SLN, NY1, CIN, BOS, PHA, SLN, SLA, BRO, CIN, BRO, PHA, C…\n$ lgID     &lt;fct&gt; NL, NL, NL, NL, AL, AL, NL, AL, NL, NL, NL, AL, NL, AL, AL, N…\n$ W        &lt;int&gt; 18, 1, 12, 0, 4, 3, 6, 3, 15, 12, 10, 23, 0, 3, 2, 2, 9, 2, 2…\n$ L        &lt;int&gt; 9, 2, 11, 0, 7, 2, 7, 18, 15, 14, 27, 5, 1, 4, 2, 0, 23, 2, 1…\n$ G        &lt;int&gt; 34, 4, 33, 7, 18, 15, 26, 34, 35, 35, 44, 30, 12, 13, 6, 19, …\n$ GS       &lt;int&gt; 30, 3, 23, 2, 13, 3, 11, 20, 30, 26, 36, 28, 2, 8, 5, 5, 29, …\n$ CG       &lt;int&gt; 16, 2, 13, 0, 2, 2, 5, 13, 25, 11, 25, 25, 0, 2, 4, 2, 16, 2,…\n$ SHO      &lt;int&gt; 3, 0, 3, 0, 0, 0, 0, 0, 2, 2, 4, 3, 0, 0, 1, 0, 1, 0, 6, 0, 0…\n$ SV       &lt;int&gt; 0, 0, 0, 0, 0, 2, 2, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 3, 7, 0, 0…\n$ IPouts   &lt;int&gt; 735, 83, 571, 52, 300, 171, 348, 577, 815, 643, 930, 750, 114…\n$ H        &lt;int&gt; 217, 35, 161, 16, 106, 53, 117, 186, 267, 193, 267, 182, 44, …\n$ ER       &lt;int&gt; 61, 19, 47, 9, 32, 17, 39, 71, 87, 73, 91, 44, 20, 22, 14, 19…\n$ HR       &lt;int&gt; 4, 1, 3, 0, 1, 0, 4, 2, 2, 3, 4, 1, 1, 0, 0, 2, 4, 0, 3, 1, 0…\n$ BB       &lt;int&gt; 60, 20, 63, 17, 24, 23, 53, 97, 107, 94, 82, 47, 23, 32, 12, …\n$ SO       &lt;int&gt; 101, 10, 94, 11, 33, 29, 41, 90, 87, 93, 102, 155, 15, 24, 25…\n$ BAOpp    &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ ERA      &lt;dbl&gt; 2.24, 6.18, 2.22, 4.67, 2.88, 2.68, 3.03, 3.32, 2.88, 3.07, 2…\n$ IBB      &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ WP       &lt;int&gt; 1, 1, 9, 1, 3, 0, 3, 8, 3, 7, 1, 7, 1, 1, 1, 0, 9, 1, 6, 4, 3…\n$ HBP      &lt;int&gt; 6, 0, 6, 1, 3, 1, 2, 10, 6, 7, 4, 10, 1, 3, 4, 3, 4, 0, 4, 2,…\n$ BK       &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0…\n$ BFP      &lt;int&gt; 971, 126, 747, 80, 401, 233, 497, 816, 1083, 884, 1194, 936, …\n$ GF       &lt;int&gt; 3, 1, 5, 5, 5, 9, 11, 9, 4, 6, 7, 2, 10, 4, 1, 13, 11, 5, 14,…\n$ R        &lt;int&gt; 95, 22, 78, 15, 41, 33, 55, 133, 105, 101, 127, 63, 34, 25, 1…\n$ SH       &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ SF       &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ GIDP     &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ SO9      &lt;dbl&gt; 3.710204, 3.253012, 4.444834, 5.711538, 2.970000, 4.578947, 3…\n\n\nNow that the data are in the right format, we can use geom_boxplot to visualize the within-year variation.\n\nso9 |&gt;\n  ggplot(aes(x=factor(yearID),y=SO9)) +\n  geom_boxplot(fill='white',color='black') +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic()\n\n\n\n\n\n\n\n\nOkay we’re getting closer! Here, we can see that not only is the mean SO/9 increasing over time, but so too is the variability from year to year.\nWe can see this since the difference between the top of each box and the bottom of each box, the 75th and 25th percentiles, respectively, tends to widen as we move from left to right across the graphic.\nBut notice what’s going on the x-axis. The tick mark labels are all overlapping to the point where they are completely illegible.\nFortunately, we have a few tricks to modify the tick marks on either the x or y axis. One such trick is to change the angle of the tick mark labels on the x-axis using the element_text function within the versatile theme function:\n\nso9 |&gt;\n  ggplot(aes(x=factor(yearID),y=SO9)) +\n  geom_boxplot(fill='white',color='black') +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(angle=45))\n\n\n\n\n\n\n\n\nThis may be a useful trick in some situations, but here, since we have so many tick mark labels, it didn’t really help.\nWhat if instead we only included the tick mark labels for every 10 years? We can do this with the scale_x_discrete function much like we did in Chapter 4. Here, we’ll use the breaks argument to specify the tick mark labels we want to include:\n\nso9 |&gt;\n  ggplot(aes(x=factor(yearID),y=SO9)) +\n  geom_boxplot(fill='white',color='black') +\n  labs(x=\"Season\",\n       y=\"Average Number of Strikeouts per 9 Innings Pitched\",\n       title=\"Changes in Strikeouts per 9 Innings Pitched\",\n       subtitle=\"Between the 1910 & 2023 Regular Seasons\") +\n  theme_classic() +\n  scale_x_discrete(breaks=seq(1910,2023,10))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Communicating Variation</span>"
    ]
  }
]