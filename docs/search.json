[
  {
    "objectID": "intro.html#why-use-r",
    "href": "intro.html#why-use-r",
    "title": "1  Introduction",
    "section": "1.1 Why Use R?",
    "text": "1.1 Why Use R?\nYou may be asking yourself, out of all of the possible visualization softwares which exist, why should I spend time learning and using R?\nGreat question!\nR is a useful tool and worthwhile to learn for several reasons:\n\nIt’s free!\nBecause it’s open source, thousands of people have contributed packages and functions at a pace that proprietary softwares can’t compete with\nIt is very flexible and robust meaning there’s a lot you can do with it (including creating this very website!)\nIt is becoming widely used across many industries\nWe can create visualizations and perform quantitative analyses in the same system."
  },
  {
    "objectID": "intro.html#so-what-is-r",
    "href": "intro.html#so-what-is-r",
    "title": "1  Introduction",
    "section": "1.2 So What is R?",
    "text": "1.2 So What is R?\nR is a command-line, object-oriented programming language commonly used for data analysis and statistics.\nCommand-line means that we have to give R commands in order for us to get it to do something. So for instance, if we wanted to know what the sum of 3 and 5 were, we can use R to solve this problem for us:\n\n## Adding 3 & 5 Together: ##\n3 + 5\n\n[1] 8\n\n\nObject-oriented means that we can save individual pieces of output as some name that we can use later. This is a super handy feature, especially when you have complicated scripts!\n\n## Saving the result of 3 + 5 as a ##\na &lt;- 3 + 5\na\n\n[1] 8"
  },
  {
    "objectID": "intro.html#what-can-r-do",
    "href": "intro.html#what-can-r-do",
    "title": "1  Introduction",
    "section": "1.3 What Can R Do?",
    "text": "1.3 What Can R Do?\nWhat can R do? Well, for the purpose of data analytics, I am yet to find a limit of what it can do!\nIn this class, we will be using R as a tool for visualizing categorical and quantitative data through various means."
  },
  {
    "objectID": "intro.html#functions-in-r",
    "href": "intro.html#functions-in-r",
    "title": "1  Introduction",
    "section": "1.4 Functions in R",
    "text": "1.4 Functions in R\nIn order to visualize data in R, we need to be able to import data into R. There are a variety of ways of importing data into R, but they largely depend on the type of datafile that you are importing (e.g., Excel file, CSV file, text file, etc.). While there are lots of different files which can be imported into R (Google and ChatGPT are excellent resources for searching for code for how to do something), we’ll mostly use two types in this class: Excel and CSV\nLet’s try importing the HEART.csv file into R. This file is part of the famous Framingham Heart Study.\nSince we set up our first class session by connecting to GitHub, we should have this file in our project folder already.\nTo read in this CSV file, we will use the read_csv function which is part of the readr package. Every function in R requires arguments specified inside of parentheses. We can think of packages like toolboxes within a mechanic’s workshop. Each toolbox contains different tools. A tool is like a function; we use specific tools (functions) to solve specific problems!\n\nread_csv is a tool we use to solve the problem of reading CSV files into R.\nThe read_csv tools is stored within the readr toolbox (package)."
  },
  {
    "objectID": "intro.html#importing-data-into-r",
    "href": "intro.html#importing-data-into-r",
    "title": "1  Introduction",
    "section": "1.5 Importing Data into R",
    "text": "1.5 Importing Data into R\nWhile many packages come installed in RStudio automatically, there are far, far more which we have to install from the web, including readr.\nTo install a package, we use the install.packages function:\n\n## Installing the readr package ##\ninstall.packages('readr')\n\nWe can also think of functions like mathematical functions; we have to supply the function with special inputs called arguments in order to get the desired output. For instance, in the install.packages function, we had to specify to the function which package we wanted to install.\nHow do we know what arguments to specify for a given function? There are lots of different ways, but one way we can do so is by using the ? operator.\n\n## What are the arguments of read_csv? ##\n?readr::read_csv\n\nAs we can see, there are a lot of arguments we can specify. However, we don’t need to specify most of them in this case. All of the arguments which have an = after them, like “col_names = TRUE”, will retain that specific argument unless you explicitly change it. I refer to these as optional arguments, those arguments whose value doesn’t necessarily need to be changed in order to get the function to execute.\nTo note, col_names = TRUE means that the columns of the CSV file have names. If they don’t, then we would change it to, col_names = FALSE and the column names will have generic names, (V1, V2, ... , VN).\nConversely, any argument which does not have an already specified value is a required argument, or one the user (that’s you!) must fill in for the function to execute. In the case of read_csv, that required argument is the file path!\n\nlibrary(readr)\nheart &lt;- read_csv(\"Introduction to R and RStudio/HEART.csv\")\n\nWhat about an Excel file? How do we import those? What if we want to read in the esoph.xlsx file? In this case, we can use a function called read_xlsx which is part of the package readxl. So just as before, we can run:\n\ninstall.packages('readxl')\nlibrary(readxl)\nesoph &lt;- read_xlsx(\"Introduction to R and RStudio/esoph.xlsx\")"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DATA 3230 - Data Visualization",
    "section": "",
    "text": "Preface\nWelcome to DATA 3230 - Data Visualization! My name is Dr Austin Brown and I am a faculty member in the School of Data Science and Analytics at Kennesaw State University.\nThis course is designed to teach students not only how to create data visualizations, but how to create them in an appropriate and aesthetically pleasing manner.\n\n\nCoding Requirements\nIn this course, I use R programming and specifically elements of the tidyverse to teach students how to generate beautiful visualizations using the popular visualization package, ggplot2. Now, you may be asking yourself: “what if I don’t have experience with R programming? Can I still be successful?”\nThe answer is unequivocally, yes! We start from the basics and work our way up to more complex examples, making sure that you have all the relevant code and explanations you need to be successful in this class and beyond.\nAll I ask is that along the way, if you run into issues, be sure to ask for help! That’s what I’m here for!\nSo if you’re ready to learn how to tell stories with data through a visual medium, come along with me!"
  },
  {
    "objectID": "intro.html#exploring-dataframes-using-r",
    "href": "intro.html#exploring-dataframes-using-r",
    "title": "1  Introduction",
    "section": "1.6 Exploring Dataframes using R",
    "text": "1.6 Exploring Dataframes using R\nSo far we have imported some datasets into the RStudio environment…how do we know they imported correctly? The best way that I have found which uses a combination of some traditional functions is a function called glimpse which is part of an incredibly useful data wrangling package called dplyr:\n\ninstall.packages('dplyr')\nlibrary(dplyr)\nheart |&gt;\n  glimpse()\n\n\n\nRows: 5,209\nColumns: 17\n$ Status         &lt;chr&gt; \"Dead\", \"Dead\", \"Alive\", \"Alive\", \"Alive\", \"Alive\", \"Al…\n$ DeathCause     &lt;chr&gt; \"Other\", \"Cancer\", NA, NA, NA, NA, NA, \"Other\", NA, \"Ce…\n$ AgeCHDdiag     &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 57, 55, 79,…\n$ Sex            &lt;chr&gt; \"Female\", \"Female\", \"Female\", \"Female\", \"Male\", \"Female…\n$ AgeAtStart     &lt;dbl&gt; 29, 41, 57, 39, 42, 58, 36, 53, 35, 52, 39, 33, 33, 57,…\n$ Height         &lt;dbl&gt; 62.50, 59.75, 62.25, 65.75, 66.00, 61.75, 64.75, 65.50,…\n$ Weight         &lt;dbl&gt; 140, 194, 132, 158, 156, 131, 136, 130, 194, 129, 179, …\n$ Diastolic      &lt;dbl&gt; 78, 92, 90, 80, 76, 92, 80, 80, 68, 78, 76, 68, 90, 76,…\n$ Systolic       &lt;dbl&gt; 124, 144, 170, 128, 110, 176, 112, 114, 132, 124, 128, …\n$ MRW            &lt;dbl&gt; 121, 183, 114, 123, 116, 117, 110, 99, 124, 106, 133, 1…\n$ Smoking        &lt;dbl&gt; 0, 0, 10, 0, 20, 0, 15, 0, 0, 5, 30, 0, 0, 15, 30, 10, …\n$ AgeAtDeath     &lt;dbl&gt; 55, 57, NA, NA, NA, NA, NA, 77, NA, 82, NA, NA, NA, NA,…\n$ Cholesterol    &lt;dbl&gt; NA, 181, 250, 242, 281, 196, 196, 276, 211, 284, 225, 2…\n$ Chol_Status    &lt;chr&gt; NA, \"Desirable\", \"High\", \"High\", \"High\", \"Desirable\", \"…\n$ BP_Status      &lt;chr&gt; \"Normal\", \"High\", \"High\", \"Normal\", \"Optimal\", \"High\", …\n$ Weight_Status  &lt;chr&gt; \"Overweight\", \"Overweight\", \"Overweight\", \"Overweight\",…\n$ Smoking_Status &lt;chr&gt; \"Non-smoker\", \"Non-smoker\", \"Moderate (6-15)\", \"Non-smo…\n\n\nAs we visually inspect the first few rows of the HEART dataframe, we can see that the “Sex” variable appears to be categorical whereas the “Weight” variable appears to be quantitative.\n\nA quantitative variable is something which can be measured with a number, like dollars, time, height, weight, blood pressure, etc. R refers to these as “numeric” variables.\nA categorical variable is just the opposite. It is something which cannot be quantified and is more of a quality. These are things like sex, country of origin, hair color, cause of death etc. R refers to these as “character” variables.\n\nYou may be asking yourself, “why does this matter?” It’s important for two primary reasons:\n\nThe type of variable we are working with dictates to us which visualization methods would be most appropriate.\nIn terms of R programming, we can look at the variable “Sex” and “Height” in the heart dataframe and conclude that these are categorical and quantitative variables, respectively. But when we read the heart dataframe into R using readr::read_csv, we didn’t have to tell R what types of variables each column was; it by default scans each column and makes a best guess as to what type of variable the column contains.\n\nSo how can we know that R properly recognized the variables in the heart dataframe?\nLet’s take a second glimpse!\n\n\n\nheart |&gt;\n  glimpse()\n\nRows: 5,209\nColumns: 17\n$ Status         &lt;chr&gt; \"Dead\", \"Dead\", \"Alive\", \"Alive\", \"Alive\", \"Alive\", \"Al…\n$ DeathCause     &lt;chr&gt; \"Other\", \"Cancer\", NA, NA, NA, NA, NA, \"Other\", NA, \"Ce…\n$ AgeCHDdiag     &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 57, 55, 79,…\n$ Sex            &lt;chr&gt; \"Female\", \"Female\", \"Female\", \"Female\", \"Male\", \"Female…\n$ AgeAtStart     &lt;dbl&gt; 29, 41, 57, 39, 42, 58, 36, 53, 35, 52, 39, 33, 33, 57,…\n$ Height         &lt;dbl&gt; 62.50, 59.75, 62.25, 65.75, 66.00, 61.75, 64.75, 65.50,…\n$ Weight         &lt;dbl&gt; 140, 194, 132, 158, 156, 131, 136, 130, 194, 129, 179, …\n$ Diastolic      &lt;dbl&gt; 78, 92, 90, 80, 76, 92, 80, 80, 68, 78, 76, 68, 90, 76,…\n$ Systolic       &lt;dbl&gt; 124, 144, 170, 128, 110, 176, 112, 114, 132, 124, 128, …\n$ MRW            &lt;dbl&gt; 121, 183, 114, 123, 116, 117, 110, 99, 124, 106, 133, 1…\n$ Smoking        &lt;dbl&gt; 0, 0, 10, 0, 20, 0, 15, 0, 0, 5, 30, 0, 0, 15, 30, 10, …\n$ AgeAtDeath     &lt;dbl&gt; 55, 57, NA, NA, NA, NA, NA, 77, NA, 82, NA, NA, NA, NA,…\n$ Cholesterol    &lt;dbl&gt; NA, 181, 250, 242, 281, 196, 196, 276, 211, 284, 225, 2…\n$ Chol_Status    &lt;chr&gt; NA, \"Desirable\", \"High\", \"High\", \"High\", \"Desirable\", \"…\n$ BP_Status      &lt;chr&gt; \"Normal\", \"High\", \"High\", \"Normal\", \"Optimal\", \"High\", …\n$ Weight_Status  &lt;chr&gt; \"Overweight\", \"Overweight\", \"Overweight\", \"Overweight\",…\n$ Smoking_Status &lt;chr&gt; \"Non-smoker\", \"Non-smoker\", \"Moderate (6-15)\", \"Non-smo…\n\n\nSex, for example, we can imagine is a categorical variable as its values, male and female, are characteristics and not numbers.\n\nWe can tell R read it in as a categorical variable because it is coded as character (notice the &lt;chr&gt; to the right of the Sex variable name).\nHeight, on the other hand, we can imagine is a quantitative variable as its values are numbers!\n\nWe can tell R read it in as a quantitative variable because it is coded as double (notice the &lt;dbl&gt; to the right of the Height variable name)."
  },
  {
    "objectID": "intro.html#examining-subsets-of-dataframes",
    "href": "intro.html#examining-subsets-of-dataframes",
    "title": "1  Introduction",
    "section": "1.7 Examining Subsets of Dataframes",
    "text": "1.7 Examining Subsets of Dataframes\n\n1.7.1 Single Variable Analysis\nLet’s say I wanted to find the average or mean Age at Death from the heart dataframe. How would I go about doing that?\nFirst, I need to know how to isolate that single variable by itself. To do this, we make use of the dollar-sign operator after the name of our dataframe.\nYou can think of the dollar-sign operator like a door to your home. The name of the dataframe is the house itself, the dollar-sign is the door, and the variable name is the person we want to talk to inside of the house.\nSo the structure is: House$Person\nIf we enter the following command into our console, we can see that we have returned to us the observations contained withing the Age at Death column:\n\nheart$AgeAtDeath\n\n\n\n [1] 55 57 NA NA NA NA NA 77 NA 82\n\n\nSo now that we know how to isolate a single variable within a dataframe, let’s try finding the mean of this quantitative variable using the below code:\n\nmean(heart$AgeAtDeath)\n\n[1] NA\n\n\nWhat is returned to us in NA meaning “Not-Applicable.” How does this make any sense? Sometimes, when I get output that is different than what I’m expecting, I check the documentation to see if there are any arguments within the given function that might need changed to have the function return output I expect. Remember, we can do that with the ? operator:\n\n?mean\n\nWhat we find in the documentation is the structure of the function, just like we saw for read_csv. Here, the structure of mean is:\nmean(x, trim = 0, na.rm = FALSE, ...)\nBelow, we can see the descriptions of each argument. When we examine na.rm it states: “a logical evaluating to TRUE or FALSE indicating whether NA values should be stripped before the computation proceeds.”\nSo in other words, if a numeric column contains missing values and we try to calculate the mean of said column, when the mean function approaches a missing value, it simply doesn’t know what to do with it. This makes sense as a missing value could be anything (0, 1000, \\(\\pi\\), or anything else!). So instead of trying to guess what the value is, it just returns NA. To have it just omit the missing values to have the function return to us the sample mean, we need to run the code:\n\nmean(heart$AgeAtDeath,na.rm=T)\n\n[1] 70.53641\n\n\nNow we get a result from the function that makes more sense!\n\n\n1.7.2 Selecting Subsets of Columns\nLet’s say I have a large dataframe with lots of columns, as you might see in your own fields of study. But, for whatever analysis I’m wanting to do, I don’t need all of the columns, just a few. In such a case, it might be useful to subset the dataframe and select only the columns we need.\nHow do we go about doing this? Like many things in R, there are a few different ways to yield the same result, but I’m going to show you what I consider the most straightforward method, which uses the dplyr package.\nUsing the heart dataframe, suppose I want to create a new dataframe which only contains the last four columns: Chol_Status, BP_Status, Weight_Status, and Smoking_Status. To do this, we will use the select function from within the dplyr package.\n\nheart_status &lt;- heart |&gt;\n  select(Chol_Status,BP_Status,\n         Weight_Status,Smoking_Status)\n\nheart_status |&gt;\n  glimpse()\n\nRows: 5,209\nColumns: 4\n$ Chol_Status    &lt;chr&gt; NA, \"Desirable\", \"High\", \"High\", \"High\", \"Desirable\", \"…\n$ BP_Status      &lt;chr&gt; \"Normal\", \"High\", \"High\", \"Normal\", \"Optimal\", \"High\", …\n$ Weight_Status  &lt;chr&gt; \"Overweight\", \"Overweight\", \"Overweight\", \"Overweight\",…\n$ Smoking_Status &lt;chr&gt; \"Non-smoker\", \"Non-smoker\", \"Moderate (6-15)\", \"Non-smo…\n\n\nOkay, great! But what if we instead wanted to subset the heart dataframe by characteristics of the rows, instead? For example, let’s say in the new heart_status dataframe we just created, we want to create a new dataframe where we only have those participants whose Weight_Status is “Overweight.” To do this, we can now instead use the filter function which is also contained within the powerful and useful dplyr package:\n\nheart_status_ow &lt;- heart_status |&gt;\n  filter(Weight_Status == 'Overweight')\n\nIf you’re familiar with SQL, dplyr operates in much the same manner. So most anything we can do from a data wrangling perspective with SQL, we can also with dplyr."
  }
]